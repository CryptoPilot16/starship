<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>CRYPTO STARSHIP â€” RESEARCH ðŸš€</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#0b1118" />

  <!-- Icons from /public (match your folder) -->
  <link rel="icon" type="image/png" sizes="16x16" href="/csr-favicon-16.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/csr-favicon-32.png">
  <link rel="icon" type="image/png" href="/csr-favicon.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/csr-apple-touch-180.png">
  <meta property="og:image" content="/csr-logo-512.png">

  <!-- Styles -->
  <link rel="stylesheet" href="/starship.css">
</head>
<body>

  <!-- Top Banner -->
  <header class="site-header">
    <a class="header-inner" href="/" aria-label="Crypto Starship â€” Research ðŸš€">
      <picture>
        <source media="(max-width: 640px)" srcset="/banner-1500x280.png">
        <source media="(max-width: 1920px)" srcset="/banner-1920x300.png">
        <source media="(min-width: 1921px)" srcset="/banner-4k-3840x640.png">
        <img src="/banner-2560x420.png" alt="CRYPTO STARSHIP â€” RESEARCH" class="site-banner">
      </picture>
    </a>
  </header>

  <!-- Page content -->
  <main class="page">
    <div class="app-shell">

      <h2 class="section-title">CRYPTO STARSHIP â€” SOLANA (REALTIME â€¢ 4H WINDOWS, 60H CAP)</h2>
      <div class="hint">Click <strong>Refresh</strong> â†’ toggle 4h pills â†’ <strong>Fetch</strong></div>

      <!-- Controls Grid -->
      <div class="row controls">

        <!-- Token -->
        <div class="card grow">
          <label class="label" for="tokenInput">Token Mint Address Â· Name:</label>
          <div class="token-row">
            <input id="tokenInput" class="input" spellcheck="false"
              placeholder="So11111111111111111111111111111111111111112"
              value="H8xQ6poBjB9DTPMDTKWzWPtmxu4bDEhybxiouF8Ppump" />
          </div>
          <div class="token-meta">
            <span id="tokenName" class="muted">The Spirit of Gambling</span>
          </div>
        </div>

        <!-- Limit / Refresh -->
        <div class="card narrow">
          <label class="label" for="limitInput">Limit / window</label>
          <input id="limitInput" type="number" min="10" max="1000" step="10" class="input" value="100" />
        </div>

        <div class="card actions">
          <button id="refreshBtn" class="btn btn-strong">REFRESH</button>
          <button id="selectAllBtn" class="btn">SELECT ALL</button>
          <button id="clearBtn" class="btn">CLEAR</button>
        </div>
      </div>

      <!-- Windows pills -->
      <div class="card">
        <div class="label">4h windows (newest first): click pills to toggle selection.</div>
        <div id="windowsWrap" class="pills"></div>
        <div class="pill-legend">
          <span class="pill demo selected">selected</span>
          <span class="pill demo">unselected</span>
        </div>
      </div>

      <!-- Filters -->
      <div class="row">
        <div class="card">
          <label class="label" for="minSol">Min SOL</label>
          <input id="minSol" class="input" placeholder="e.g. 0.1">
        </div>
        <div class="card">
          <label class="label" for="maxSol">Max SOL</label>
          <input id="maxSol" class="input" placeholder="e.g. 5">
        </div>

        <div class="card grow align-end">
          <button id="fetchBtn" class="btn btn-accent">FETCH</button>
        </div>
      </div>

      <!-- Status / Errors -->
      <div id="status" class="status"></div>

      <!-- Results (optional holder, fill after fetch) -->
      <div id="results" class="results card" hidden>
        <div class="label">Results</div>
        <pre id="resultsPre" class="pre"></pre>
      </div>
    </div>
  </main>

  <script>
    // ======= CONFIG =======
    const WINDOW_SIZE_HOURS = 4;
    const MAX_CAP_HOURS = 60;         // change to 68 if you want
    const USE_SERVER_TIME_ENDPOINT = '/api/time';   // GET { now: <ms epoch> }
    const FETCH_ENDPOINT = '/api/fetch';            // POST { token, windows:[{since,till}], limit, minSol, maxSol }

    // ======= DOM =======
    const tokenInput = document.getElementById('tokenInput');
    const tokenName  = document.getElementById('tokenName');
    const limitInput = document.getElementById('limitInput');
    const windowsWrap = document.getElementById('windowsWrap');
    const minSolEl = document.getElementById('minSol');
    const maxSolEl = document.getElementById('maxSol');
    const refreshBtn = document.getElementById('refreshBtn');
    const selectAllBtn = document.getElementById('selectAllBtn');
    const clearBtn = document.getElementById('clearBtn');
    const fetchBtn = document.getElementById('fetchBtn');
    const statusEl = document.getElementById('status');
    const results = document.getElementById('results');
    const resultsPre = document.getElementById('resultsPre');

    // Keep selected windows in memory
    let generatedWindows = []; // [{since,till,label}]
    let selectedMap = new Map(); // key: label -> boolean

    // ======= Helpers =======
    const pad2 = n => String(n).padStart(2,'0');
    const fmtLabel = (since, till) => {
      // label like: "08-21 07:00 â€” 08-21 11:00"
      const s = new Date(since);
      const t = new Date(till);
      const sLabel = `${pad2(s.getMonth()+1)}-${pad2(s.getDate())} ${pad2(s.getHours())}:00`;
      const tLabel = `${pad2(t.getMonth()+1)}-${pad2(t.getDate())} ${pad2(t.getHours())}:00`;
      return `${sLabel} â€” ${tLabel}`;
    };

    function showStatus(msg, type='info'){
      statusEl.textContent = msg;
      statusEl.className = 'status ' + type;
    }

    function msToAlignedWindows(nowMs){
      // Build 4h windows aligned on UTC 00,04,08,12,16,20 up to MAX_CAP_HOURS
      const sizeMs = WINDOW_SIZE_HOURS * 3600_000;
      const capMs = MAX_CAP_HOURS * 3600_000;

      const now = new Date(nowMs);
      // align "till" to the last completed boundary (server is source of truth)
      const utcH = now.getUTCHours();
      const alignedH = utcH - (utcH % WINDOW_SIZE_HOURS);
      const alignedTill = Date.UTC(
        now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(),
        alignedH, 0, 0, 0
      );
      const firstSince = alignedTill - sizeMs;
      const oldestAllowed = alignedTill - capMs;

      const windows = [];
      let since = firstSince;
      let till  = alignedTill;
      while (till > oldestAllowed) {
        windows.push({ since, till, label: fmtLabel(since, till) });
        till = since;
        since = till - sizeMs;
      }
      return windows; // newest first
    }

    function renderPills(windows){
      windowsWrap.innerHTML = '';
      windows.forEach(w => {
        const pill = document.createElement('button');
        pill.className = 'pill' + (selectedMap.get(w.label) ? ' selected' : '');
        pill.textContent = w.label;
        pill.dataset.label = w.label;
        pill.title = 'Click to toggle';
        pill.addEventListener('click', () => {
          const cur = !!selectedMap.get(w.label);
          selectedMap.set(w.label, !cur);
          pill.classList.toggle('selected', !cur);
        });
        windowsWrap.appendChild(pill);
      });
    }

    async function getServerNow(){
      try{
        const r = await fetch(USE_SERVER_TIME_ENDPOINT, { cache:'no-store' });
        if(!r.ok) throw new Error('HTTP '+r.status);
        const j = await r.json();
        if(typeof j.now !== 'number') throw new Error('Invalid server time payload');
        return j.now;
      }catch(e){
        console.warn('Server time unavailable, using local clock:', e.message);
        return Date.now();
      }
    }

    async function refreshWindows(){
      showStatus('Refreshing 4h windowsâ€¦', 'info');
      const now = await getServerNow();
      generatedWindows = msToAlignedWindows(now);
      // Keep previously selected labels if they still exist
      const keep = new Map();
      generatedWindows.forEach(w => keep.set(w.label, selectedMap.get(w.label) || false));
      selectedMap = keep;
      renderPills(generatedWindows);
      showStatus(`Loaded ${generatedWindows.length} windows (newest first).`, 'ok');
      bumpRefresh();
    }

    function bumpRefresh(){
      // brief visual pop
      refreshBtn.classList.add('pulse');
      setTimeout(()=>refreshBtn.classList.remove('pulse'), 500);
    }

    function selectAll(){
      generatedWindows.forEach(w => selectedMap.set(w.label, true));
      renderPills(generatedWindows);
    }
    function clearAll(){
      selectedMap = new Map();
      renderPills(generatedWindows);
    }

    function gatherSelectedWindows(){
      const set = [];
      const wanted = new Set([...selectedMap.entries()].filter(([_,v])=>v).map(([k])=>k));
      generatedWindows.forEach(w => {
        if(wanted.has(w.label)) set.push({ since: w.since, till: w.till, label: w.label });
      });
      return set;
    }

    async function doFetch(){
      const token = tokenInput.value.trim();
      const limit = parseInt(limitInput.value, 10) || 100;
      const minSol = parseFloat(minSolEl.value || '0');
      const maxSol = parseFloat(maxSolEl.value || '0');
      const selected = gatherSelectedWindows();

      if(!token){ showStatus('Enter a token address first.', 'err'); return; }
      if(selected.length === 0){ showStatus('Select at least one 4h window.', 'err'); return; }

      showStatus('Fetchingâ€¦', 'info');
      results.hidden = true;

      try{
        const r = await fetch(FETCH_ENDPOINT, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ token, windows: selected, limit, minSol, maxSol })
        });
        if(!r.ok){
          const text = await r.text();
          throw new Error(`HTTP ${r.status} ${text}`);
        }
        const data = await r.json();
        showStatus('Done.', 'ok');
        results.hidden = false;
        resultsPre.textContent = JSON.stringify(data, null, 2);
      }catch(e){
        showStatus(`Error fetching: ${e.message}`, 'err');
      }
    }

    // ======= Events =======
    refreshBtn.addEventListener('click', refreshWindows);
    selectAllBtn.addEventListener('click', selectAll);
    clearBtn.addEventListener('click', clearAll);
    fetchBtn.addEventListener('click', doFetch);

    // Update token name when user types (only display purpose)
    tokenInput.addEventListener('input', () => {
      tokenName.textContent = tokenInput.value ? '(custom token)' : 'The Spirit of Gambling';
    });

    // Initial load
    refreshWindows();
  </script>
</body>
</html>
